Проблемы с контролем доступа характерны для всех программ, а не только для смарт-контрактов. Фактически, это номер 5 в топ-10 OWASP. Обычно доступ к функциональности контракта осуществляется через его общедоступные или внешние функции. В то время как небезопасные настройки видимости дают злоумышленникам прямой доступ к частным значениям или логике контракта, обходы контроля доступа иногда бывают более тонкими. Эти уязвимости могут возникать, когда контракты используют устаревший tx.origin для проверки вызывающих объектов, обработки большой логики авторизации с длительным запросом и безрассудного использования делегата в библиотеках прокси или контрактах прокси. 
Пример:

    Смарт-контракт назначает адрес, который его инициализирует, в качестве владельца контракта. Это распространенный шаблон для предоставления особых привилегий, таких как возможность снимать средства контракта.
    К сожалению, функцию инициализации может вызвать кто угодно — даже после того, как она уже была вызвана. Разрешение любому стать владельцем контракта и забрать его средства.

Пример кода:

В следующем примере функция инициализации контракта устанавливает вызывающую функцию в качестве ее владельца. Однако логика отделена от конструктора контракта и не отслеживает тот факт, что он уже был вызван. 
```
function initContract() public {
	owner = msg.sender;
}
```