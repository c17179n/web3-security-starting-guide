Одной из более глубоких возможностей Solidity являются низкоуровневые функции call(), callcode(), delegatecall() и send(). Их поведение при учете ошибок сильно отличается от других функций Solidity, поскольку они не будут распространяться (или всплывать) и не приведут к полному откату текущего выполнения. Вместо этого они вернут логическое значение, равное false, и код продолжит выполнение. Это может удивить разработчиков и, если не проверять возвращаемое значение таких низкоуровневых вызовов, может привести к отказу в открытии и другим нежелательным последствиям. Помните, отправить может не получиться! 
Пример кода:

Следующий код является примером того, что может пойти не так, если забыть проверить возвращаемое значение send(). Если вызов используется для отправки эфира смарт-контракту, который их не принимает (например, потому что у него нет оплачиваемой резервной функции), EVM заменит возвращаемое значение на false. Поскольку в нашем примере возвращаемое значение не проверяется, изменения функции в состоянии контракта не будут отменены, и переменная etherLeft в конечном итоге будет отслеживать неверное значение: 
```
function withdraw(uint256 _amount) public {
	require(balances[msg.sender] >= _amount);
	balances[msg.sender] -= _amount;
	etherLeft -= _amount;
	msg.sender.send(_amount);
}
```