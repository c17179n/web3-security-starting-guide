Случайность трудно реализовать правильно в Эфириуме. Хотя Solidity предлагает функции и переменные, которые могут получить доступ к явно трудно предсказуемым значениям, они, как правило, либо более общедоступны, чем кажутся, либо подвержены влиянию майнеров. Поскольку эти источники случайности в определенной степени предсказуемы, злоумышленники обычно могут воспроизвести их и атаковать функцию, полагаясь на ее непредсказуемость. 
Пример:
арт-контракт использует номер блока как источник случайности для игры.
    Злоумышленник создает вредоносный контракт, который проверяет, является ли текущий номер блока победителем. Если это так, он вызывает первый смарт-контракт, чтобы выиграть; поскольку вызов будет частью одной и той же транзакции, номер блока останется одинаковым для обоих контрактов.
    Злоумышленнику нужно только вызвать ее злонамеренный контракт, пока он не выиграет.

Пример кода:

В этом первом примере частное начальное число используется в сочетании с номером итерации и хэш-функцией keccak256, чтобы определить, выигрывает ли вызывающий. Несмотря на то, что семя является частным, оно должно быть установлено через транзакцию в какой-то момент времени и, таким образом, видно в блокчейне.
```
int256 private seed;

function play() public payable {
	require(msg.value >= 1 ether);
	iteration++;
	uint randomNumber = uint(keccak256(seed + iteration));
	if (randomNumber % 2 == 0) {
		msg.sender.transfer(this.balance);
	}
} Во втором примере block.blockhash используется для генерации случайного числа. Этот хэш неизвестен, если blockNumber установлен на текущий block.number (по понятным причинам) и, таким образом, установлен на 0. В случае, когда blockNumber установлен на более чем 256 блоков в прошлом, он всегда будет равен нулю . Наконец, если он установлен на предыдущий номер блока, который не является слишком старым, другой смарт-контракт может получить доступ к тому же номеру и вызвать игровой контракт как часть той же транзакции. 
```
function play() public payable {
	require(msg.value >= 1 ether);
	if (block.blockhash(blockNumber) % 2 == 0) {
		msg.sender.transfer(this.balance);
	}
}
```