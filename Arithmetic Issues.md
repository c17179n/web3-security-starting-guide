Целочисленные переполнения и потери значимости не являются новым классом уязвимостей, но они особенно опасны в смарт-контрактах, где преобладают целые числа без знака и большинство разработчиков привыкли к простым типам int (которые часто представляют собой просто целые числа со знаком). Если происходит переполнение, многие кажущиеся безобидными кодовые пути становятся векторами кражи или отказа в обслуживании. 
примеры 
Функция смарт-контракта remove() позволяет вам получить эфир, пожертвованный контракту, до тех пор, пока ваш баланс остается положительным после операции.
    Злоумышленник пытается снять больше, чем его или ее текущий баланс.
    Результатом проверки функции remove() всегда является положительная сумма, что позволяет злоумышленнику снять больше, чем разрешено. Образующийся баланс теряется и становится на порядок больше, чем должен быть. 
Самый простой пример — это функция, которая не проверяет целочисленное значение потери значимости, что позволяет вам снимать бесконечное количество токенов: 
```
function withdraw(uint _amount) {
	require(balances[msg.sender] - _amount > 0);
	msg.sender.transfer(_amount);
	balances[msg.sender] -= _amount;
}
``` 
Второй пример (замеченный во время конкурса Underhanded Solidity Coding Contest) — это ошибка «отклонение на единицу», чему способствует тот факт, что длина массива представлена ​​целым числом без знака: 
```
function popArrayOfThings() {
	require(arrayOfThings.length >= 0);
	arrayOfThings.length--; 
}
``` 
Третий пример — это вариант первого примера, где результатом арифметических действий над двумя целыми числами без знака является целое число без знака: 
```
function votes(uint postId, uint upvote, uint downvotes) {
	if (upvote - downvote < 0) {
		deletePost(postId)
	}
	В четвертом примере используется ключевое слово var, которое скоро станет устаревшим. Поскольку var изменит свой тип на наименьший тип, необходимый для хранения назначенного значения, он станет uint8 для хранения значения 0. Если цикл предназначен для повторения более 255 раз, он никогда не достигнет этого числа и остановится, когда исполнение заканчивается газ: 
```
for (var i = 0; i < somethingLarge; i ++) {
	// ...
}
