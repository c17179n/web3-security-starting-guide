Отказ в обслуживании смертельно опасен в мире Ethereum: в то время как другие типы приложений могут в конечном итоге восстановиться, смарт-контракты могут быть навсегда отключены от сети всего лишь одной из этих атак. Многие способы приводят к отказу в обслуживании, в том числе злонамеренное поведение, когда вы являетесь получателем транзакции, искусственное увеличение количества газа, необходимого для вычисления функции, злоупотребление контролем доступа для доступа к частным компонентам смарт-контрактов, использование путаницы и халатности и т. д. класс атак включает в себя множество различных вариантов и, вероятно, получит большое развитие в ближайшие годы. 
example
Аукционный контракт позволяет пользователям делать ставки на различные активы.
    Чтобы сделать ставку, пользователь должен вызвать функцию bid(uint object) с желаемым количеством эфира. Контракт аукциона будет хранить эфир на условном депонировании до тех пор, пока владелец объекта не примет ставку или первоначальный участник торгов не отменит ее. Это означает, что аукционный контракт должен содержать полную стоимость любой неразрешенной заявки на балансе.
    Аукционный контракт также содержит функцию снятия (сумма uint), которая позволяет администраторам извлекать средства из контракта. Поскольку функция отправляет сумму на жестко заданный адрес, разработчики решили сделать эту функцию общедоступной.
    Злоумышленник видит потенциальную атаку и вызывает функцию, направляя все средства контракта ее админам. Это разрушает обещание условного депонирования и блокирует все ожидающие заявки.
    В то время как админы могут вернуть депонированные деньги в контракт, злоумышленник может продолжить атаку, просто снова выведя средства.

Пример кода:

В следующем примере (навеянном King of the Ether) функция игрового контракта позволяет вам стать президентом, если вы публично подкупите предыдущего. К сожалению, если предыдущий президент является смарт-контрактом и вызывает отмену платежа, передача власти не удастся, и злонамеренный смарт-контракт навсегда останется президентом. 
```
function becomePresident() payable {
    require(msg.value >= price); // must pay the price to become president
    president.transfer(price);   // we pay the previous president
    president = msg.sender;      // we crown the new president
    price = price * 2;           // we double the price to become president
} 

Во втором примере вызывающая сторона может решить, кого вознаградит следующий вызов функции. Из-за дорогостоящих инструкций в цикле for злоумышленник может ввести число, слишком большое для повторения (из-за ограничений газового блока в Ethereum), что эффективно заблокирует работу функции. 
```
function selectNextWinners(uint256 _largestWinner) {
	for(uint256 i = 0; i < largestWinner, i++) {
		// heavy code
	}
	largestWinner = _largestWinner;
}
```